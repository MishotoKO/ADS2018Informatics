Selection sort
The sorting method by selecting the largest element refers to sorting the data series x from the n elements into a non-ordering order (similar to the least element selection, it ensures sorting in an orderly order). First, the largest element of the string is located and it comes first, then there is the largest of the remaining n1 elements, and it is brought to the second place, finds the largest of the remaining n2 elements and brings it to the third place, etc., concluding with the finding of the greater of the last two elements and its bringing to the last place. The last place will remain an element that is no greater than one in a row (the smallest element).

Insertion sort
If a string (xn) is given with elements of someone, arranged type T, which should be arranged in an orderly order, this sorting method starts from the assumption that we have arranged the initial part of the series, x1, ..., xi-1 (this certainly applies to = 2, since the subset with one element is arranged) and in each step, starting with i = 2 and increasing i, the i-th element is placed in the right place in relation to the first (arranged) i-1.

Bubble sort
The algorithm in each pass through the array compares successive elements, and exchanges them with places in the wrong order. Passes through the series are repeated until a passage is made in which there was no exchange, which means the string is sorted. Bubble sort algorithm is considered a very bad algorithm. Some authors even advocate the thesis that it should be thrown out completely from the teaching of computer science. In the joke it is even said that the only algorithm worse than him would be an algorithm that permutes the algorithm in a random way until the string accidentally becomes sorted.

Shell sort
Shellort is simply an extension of sorting by insertion that allows direct exchange of remote elements. The extension consists in passing through the insertion algorithm several times; in the first pass, instead of step 1, a step h is less than n (which allows the exchange of remote elements) to be taken, thus obtaining a h-sorted string, i.e. a series in which the elements at a distance are sorted, although the adjacent elements do not have to be. In the second pass through the same algorithm the same procedure is performed, but for a smaller step h. With passes it continues until step h = 1, in which a fully sorted string is obtained.

Quick sort
This is the most commonly used sorting algorithm. The basic algorithm was given in 1960, Hor (Hoare). It is not difficult to implement, and uses less resources (time and space) than any other sorting algorithm, in most cases. The algorithm does not require additional memory, only n * log (n) operations in average for sorting n elements, and has an extremely short internal loop. The bad side of the algorithm is that it is recursive (the non-corrosive variant is much more complex), in the worst case executes around n2 operations. There are also versions of this algorithm that improve it. The algorithm is very sensitive to implementation (efficiency can be damaged by poor selection in implementation). If the best implementation is not to be analyzed, it is better to apply a helicort. The idea of ??an algorithm consists in partitioning a string according to the selected partitioning element that is brought to the right place, and in applying a quick sorting algorithm to each of the two received partitions. A recursive call ends when applied to a partition with less than two elements.

Merge varieties
Sorting by merge or merge sort is a sorting algorithm based on comparison. It's a recursive algorithm. Its time complexity is proportional to O (n * log (n)), and in the middle case it is always more efficient than the quick sorting algorithm (quick sort)