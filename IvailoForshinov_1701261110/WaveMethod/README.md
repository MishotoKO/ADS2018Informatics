# Wave Method

## Описание на алгоритъма

### Нека r е избраният начален връх, а w(i, j ) е теглото на реброто от върха i до върха j (w(i, j ) е равно на безкрайност, ако между двата върха няма ребро). Алгоритъмът работи, като за всеки връх i пази дължината d(i) на намерения до момента най-къс път от r до i и кандидата π(i) за ребро, чрез което върхът i да бъде включен в строящото се дърво на най-къси пътища (π(i) е едно от ребрата, влизащи в i ). Алгоритъмът постепенно разширява множеството S от върховете, за които намерената дължина със сигурност е минимална, т.е. добавя нови върхове към дървото. Първоначално S = { r }, d(r) = 0, π(r) = NULL, d(i)=безкрайност и π(i) = NULL за всеки връх i, различен от r. На всяка итерация от върховете, които не са в S, алгоритъмът избира онзи връх v, за който числото d(v) е минимално. Върхът v се добавя в S, т.е. реброто π(v) се добавя към дървото, след което се извършва релаксация: за всеки връх j, който не е в S, d(j) = min(d(j), d(v) + w(v, j )) и ако второто число е по-малко, то π(j) = (v, j ). Алгоритъмът приключва, когато всички върхове на графа са в множеството S.

## Сложност на алгоритъма

### Алгоритъмът се прилага върху граф G(V, E). Най-простата реализация използва матрица на съседство за представяне на графа и едномерен вектор за съхранение на стойностите на d(). Сложността по време и по памет е O(|V|2). Ако графът бъде представен чрез списъци на съседите и за намиране на всеки следващ връх се използва приоритетна опашка, то при подходяща реализация сложността по време е O(E + |V|.log|V|), а по памет е O(|E|+|V|).

