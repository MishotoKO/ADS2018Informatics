[Математическо очакване. Кодиране с линейно предсказване]-

-Математическо очакване: Математическото очакване, известно още като средна стойност, е основно понятие в теорията на вероятностите. 

	В процеса на преминаване през символите от входното съобщение ще натрупваме статистически данни,
	позволяващи ни да пресметнем математическото очакване на следващата буква, като на изхода ще подаваме само "грешката",
	т.е. само разликата между средната стойност и кода на символа.
	Вместо да натрупваме статистика за символите на входното съобщение, както и за честотата (или вероятността) на срещане на всеки от тях,
	ще използваме проста рекурентна връзка между старата стойност на EXстар = {x1, x2, ..., xk}, и новата EXнов = {x1, x2, ..., xk, xk+1}. 

------------------------------------------------------------------------------------------------------------------------------------------
[Статистически методи]-

Алгоритъм на Шенън-Фано:
	Алгоритъмът притежава следните характерни свойства: 
	-Дължината на кодовете е променлива.
	-Буквите с по-голяма вероятност се кодират с по-малко битове от тези с по-малка вероятност. 
	-Съобщението се декодира еднозначно. 
	
	Алгоритъм:
	-Сортираме символите по вероятност на срещане в намаляващ ред. 
 	-Разделяме множеството от символите на две подмножества с (почти) равни вероятности.
	-На едното подмножество съпоставяме 0, а на другото — 1 като поредна буква.
	-Ако някое от подмножествата съдържа повече от един елемент, прилагаме за него същия процес, започвайки от стъпка 2.  

 Алгоритъм на Хъфман:
------------------------------------------------------------------------------------------------------------------------------------------------------
	void huffman(void) 
	{ /* Докато гората съдържа повече от едно дърво */  
	while (forest_съдържа_поне_2_дървета) 
	{
     	findMins(i,j);       /* 1. Намиране на двата най-редки върха */     
	forest[i] = createNew(forest[i],forest[j]);/* 2. Обединяване */     
	free(forest[j]);            /* 3. Премахване на j-тото дърво */   } 
-------------------------------------------------------------------------------------------------------------------------------------------------------	  
	-Образуваме от всеки символ тривиално дърво, в корена (единствения връх) на което записваме вероятността на срещане на съответния символ.  
	-Намираме двата върха с най-малки вероятности и ги обединяваме в ново дърво с корен, съдържащ сумата от вероятностите им.  
 	-Ако има поне две дървета, преход към 2.

[Аритметично кодиране]-
-----------------------------------------------------------------------------------
	l = 0.0; 
	r = 1.0; 
	while (getSymbol(ch)) {  
	 	range = r - l;   
		l = l + range * low_range(ch);	
		 r = l + range * high_range(ch); 
	} 
	output(l);
-----------------------------------------------------------------------------------
	-Подобно на Хъфмановото кодиране,то също се основава на статистически наблюдения за честотата на срещане на всеки от символите във входното съобщение,
	но може да постигне значително по-добри резултати, тъй като изобщо се отказва от побуквеното кодиране.
	Вместо това на цялото входно съобщение се съпоставя едно-единствено дробно число между 0 и 1 с необходимата точност.


	
	Извод!
	-При кодирането по Хъфман  не се отчита достатъчно прецизно вероятността за поява на всяка от буквите.
	-Скромна ефективност заради неподходящия избор на азбука.
	!Аритметичното кодиране решава този проблем!